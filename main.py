import os
import json
import logging
import asyncio
from datetime import datetime
from zoneinfo import ZoneInfo
from urllib.parse import urlparse

from aiohttp import web
import gspread
from google.oauth2.service_account import Credentials
from aiogram import Bot, Dispatcher, types

# ================== –õ–û–ì–ò ==================
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("points-bot")

# ================== –ö–û–ù–§–ò–ì ==================
BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
if not BOT_TOKEN:
    raise RuntimeError("TELEGRAM_BOT_TOKEN not set")

# Google Sheets
SPREADSHEET_ID = os.getenv("GOOGLE_SPREADSHEET_ID")  # –º–æ–∂–Ω–æ –Ω–µ –∑–∞–¥–∞–≤–∞—Ç—å, –µ—Å–ª–∏ –æ—Ç–∫—Ä—ã–≤–∞–µ–º –ø–æ –∏–º–µ–Ω–∏
SHEET_NAME = os.getenv("GOOGLE_SHEET_NAME", "challenge-points")

# –¢–∞–π–º–∑–æ–Ω–∞ –¥–ª—è ¬´—Å–µ–≥–æ–¥–Ω—è¬ª
LOCAL_TZ = os.getenv("LOCAL_TZ", "Europe/Amsterdam")

# –ë–∞–ª–ª—ã/—Ç–µ–≥–∏
POINTS_PER_TAG = int(os.getenv("POINTS_PER_TAG", "5"))
VALID_TAGS = {t.strip().lower() for t in os.getenv("VALID_TAGS", "#—è–∑–¥–µ—Å—å,#—á–µ–ª–ª–µ–Ω–¥–∂1").split(",")}

# –í–µ–±—Ö—É–∫ –∏ —Å–µ—Ä–≤–µ—Ä
WEBHOOK_URL = os.getenv("WEBHOOK_URL")  # –ü–æ–ª–Ω—ã–π URL, –ø—É—Ç—å –±–µ—Ä–µ–º –∫–∞–∫ –µ—Å—Ç—å
WEBAPP_HOST = "0.0.0.0"
WEBAPP_PORT = int(os.getenv("PORT", 10000))

# ================== GOOGLE SHEETS ==================
SCOPES = [
    "https://www.googleapis.com/auth/spreadsheets",
    "https://www.googleapis.com/auth/drive.readonly",
]

svc_json_env = os.getenv("GOOGLE_SERVICE_ACCOUNT_JSON")
if not svc_json_env:
    raise RuntimeError("GOOGLE_SERVICE_ACCOUNT_JSON not set")

try:
    service_account_info = json.loads(svc_json_env)
    creds = Credentials.from_service_account_info(service_account_info, scopes=SCOPES)
except Exception as e:
    raise RuntimeError(f"Invalid GOOGLE_SERVICE_ACCOUNT_JSON: {e}")

gc = gspread.authorize(creds)
try:
    if SPREADSHEET_ID:
        sh = gc.open_by_key(SPREADSHEET_ID)
    else:
        sh = gc.open(SHEET_NAME)
    sheet = sh.sheet1
except Exception as e:
    raise RuntimeError(f"Cannot open sheet (id='{SPREADSHEET_ID}' name='{SHEET_NAME}'): {e}")

HEADERS = ["User_id", "Username", "Name", "Points", "Date"]

def ensure_headers():
    try:
        values = sheet.get_all_values()
        if not values:
            sheet.update('1:1', [HEADERS])
            logger.info("–°–æ–∑–¥–∞–ª–∏ –∑–∞–≥–æ–ª–æ–≤–∫–∏ –≤ –ø—É—Å—Ç–æ–π —Ç–∞–±–ª–∏—Ü–µ")
            return
        current = values[0] if values else []
        if current[:len(HEADERS)] != HEADERS:
            sheet.update('1:1', [HEADERS])
            logger.info("–û–±–Ω–æ–≤–∏–ª–∏ —Å—Ç—Ä–æ–∫—É –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤")
    except Exception:
        logger.exception("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ–≤–µ—Ä–∏—Ç—å/–æ–±–Ω–æ–≤–∏—Ç—å –∑–∞–≥–æ–ª–æ–≤–∫–∏")

ensure_headers()

# ================== –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï ==================
def today_str() -> str:
    tz = ZoneInfo(LOCAL_TZ)
    return datetime.now(tz).date().isoformat()

def _safe_int(x) -> int:
    try:
        return int(str(x).strip())
    except Exception:
        return 0

def read_records():
    try:
        return sheet.get_all_records(expected_headers=HEADERS, default_blank="")
    except Exception:
        logger.exception("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å —Ç–∞–±–ª–∏—Ü—É")
        return []

def get_user_points(user_id: int) -> int:
    records = read_records()
    return sum(
        _safe_int(r.get("Points"))
        for r in records
        if str(r.get("User_id")) == str(user_id)
    )

def already_checked_today(user_id: int) -> bool:
    records = read_records()
    today = today_str()
    for r in records:
        if str(r.get("User_id")) == str(user_id) and str(r.get("Date")) == today:
            return True
    return False

def human_name(u: types.User) -> str:
    parts = [u.first_name or "", u.last_name or ""]
    name = " ".join(p for p in parts if p).strip()
    return name or (("@" + u.username) if u.username else str(u.id))

def add_points(user: types.User, points: int):
    row = [
        user.id,
        (user.username or "").strip(),
        human_name(user),
        int(points),
        today_str(),
    ]
    sheet.append_row(row)

def get_leaderboard(top_n: int = 10, today_only: bool = False):
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –∫–æ—Ä—Ç–µ–∂–µ–π (total, name, username, user_id)."""
    records = read_records()
    totals = {}  # user_id -> total
    names = {}   # user_id -> display name (–ø–æ—Å–ª–µ–¥–Ω—è—è –∏–∑–≤–µ—Å—Ç–Ω–∞—è)
    usernames = {}

    today = today_str()
    for r in records:
        if today_only and str(r.get("Date")) != today:
            continue
        uid = str(r.get("User_id"))
        pts = _safe_int(r.get("Points"))
        totals[uid] = totals.get(uid, 0) + pts
        nm = str(r.get("Name") or "").strip()
        un = str(r.get("Username") or "").strip()
        if nm:
            names[uid] = nm
        if un:
            usernames[uid] = un

    items = []
    for uid, total in totals.items():
        name = names.get(uid) or (("@" + usernames[uid]) if usernames.get(uid) else uid)
        items.append((total, name, usernames.get(uid, ""), uid))

    items.sort(key=lambda x: (-x[0], x[1].lower()))
    return items[:top_n]

def format_leaderboard(items, title="üèÜ –¢–æ–ø-10"):
    if not items:
        return f"{title}\n–ü–æ–∫–∞ –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö."
    lines = [title]
    for idx, (total, name, username, uid) in enumerate(items, start=1):
        handle = f" (@{username})" if username else ""
        lines.append(f"{idx}. {name}{handle} ‚Äî {total}")
    return "\n".join(lines)

async def auto_delete(bot: Bot, chat_id: int, bot_message_id: int, user_message_id: int | None = None, delay: int = 5):
    await asyncio.sleep(delay)
    try:
        await bot.delete_message(chat_id, bot_message_id)
    except Exception:
        pass
    if user_message_id:
        try:
            await bot.delete_message(chat_id, user_message_id)
        except Exception:
            pass

# ================== BOT (aiogram v2) ==================
bot = Bot(token=BOT_TOKEN)
dp = Dispatcher(bot)
Bot.set_current(bot)
Dispatcher.set_current(dp)

@dp.message_handler(commands=["start", "help"])
async def cmd_start(message: types.Message):
    sent = await message.answer("üëã –ü—Ä–∏–≤–µ—Ç! –û—Ç–º–µ—á–∞–π—Å—è —Ö–µ—à—Ç–µ–≥–æ–º #—è–∑–¥–µ—Å—å –∏–ª–∏ #—á–µ–ª–ª–µ–Ω–¥–∂1.\n–ö–æ–º–∞–Ω–¥—ã: /–±–∞–ª–∞–Ω—Å, /–∏—Ç–æ–≥–∏, /–∏—Ç–æ–≥–∏_—Å–µ–≥–æ–¥–Ω—è")
    asyncio.create_task(auto_delete(bot, message.chat.id, sent.message_id, user_message_id=message.message_id))

@dp.message_handler(commands=["–±–∞–ª–∞–Ω—Å", "balance", "–∏—Ç–æ–≥–æ"])
async def cmd_balance(message: types.Message):
    total = get_user_points(message.from_user.id)
    sent = await message.answer(f"–í–∞—à –±–∞–ª–∞–Ω—Å: {total} –±–∞–ª–ª–æ–≤")
    asyncio.create_task(auto_delete(bot, message.chat.id, sent.message_id, user_message_id=message.message_id))

@dp.message_handler(commands=["–∏—Ç–æ–≥–∏", "leaders", "—Ç–æ–ø", "top"])
async def cmd_leaders(message: types.Message):
    items = get_leaderboard(top_n=10, today_only=False)
    text = format_leaderboard(items, title="üèÜ –ò—Ç–æ–≥–∏ (–≤—Å–µ–≥–æ), —Ç–æ–ø-10")
    sent = await message.answer(text)
    asyncio.create_task(auto_delete(bot, message.chat.id, sent.message_id, user_message_id=message.message_id))

@dp.message_handler(commands=["–∏—Ç–æ–≥–∏_—Å–µ–≥–æ–¥–Ω—è", "leaders_today", "—Ç–æ–ø_—Å–µ–≥–æ–¥–Ω—è", "top_today"])
async def cmd_leaders_today(message: types.Message):
    items = get_leaderboard(top_n=10, today_only=True)
    text = format_leaderboard(items, title=f"üåû –ò—Ç–æ–≥–∏ –∑–∞ {today_str()}, —Ç–æ–ø-10")
    sent = await message.answer(text)
    asyncio.create_task(auto_delete(bot, message.chat.id, sent.message_id, user_message_id=message.message_id))

@dp.message_handler(lambda m: bool(m.text))
async def handle_text(message: types.Message):
    text = message.text.lower()
    if any(tag in text for tag in VALID_TAGS):
        user = message.from_user
        if already_checked_today(user.id):
            sent = await message.answer("‚ö†Ô∏è –°–µ–≥–æ–¥–Ω—è –≤—ã —É–∂–µ –æ—Ç–º–µ—á–∞–ª–∏—Å—å, –±–∞–ª–ª—ã –Ω–µ –Ω–∞—á–∏—Å–ª–µ–Ω—ã.")
            asyncio.create_task(auto_delete(bot, message.chat.id, sent.message_id))
            return
        try:
            add_points(user, POINTS_PER_TAG)
            total = get_user_points(user.id)
            sent1 = await message.answer("‚úÖ –ë–∞–ª–ª—ã –Ω–∞—á–∏—Å–ª–µ–Ω—ã!")
            sent2 = await message.answer(f"–í–∞—à –±–∞–ª–∞–Ω—Å: {total} –±–∞–ª–ª–æ–≤")
            asyncio.create_task(auto_delete(bot, message.chat.id, sent1.message_id))
            asyncio.create_task(auto_delete(bot, message.chat.id, sent2.message_id))
        except Exception:
            logger.exception("–û—à–∏–±–∫–∞ –ø—Ä–∏ –Ω–∞—á–∏—Å–ª–µ–Ω–∏–∏ –±–∞–ª–ª–æ–≤")
            sent = await message.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø–∏—Å–∞—Ç—å –±–∞–ª–ª—ã. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
            asyncio.create_task(auto_delete(bot, message.chat.id, sent.message_id))
    # –∏–Ω–∞—á–µ –º–æ–ª—á–∏–º

# ================== WEBHOOK / AIOHTTP ==================
def _path_from_webhook_url(default_path="/webhook"):
    if WEBHOOK_URL:
        try:
            parsed = urlparse(WEBHOOK_URL)
            return parsed.path or "/"
        except Exception:
            logger.exception("–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å WEBHOOK_URL; –∏—Å–ø–æ–ª—å–∑—É–µ–º –¥–µ—Ñ–æ–ª—Ç–Ω—ã–π –ø—É—Ç—å")
    return default_path

WEBHOOK_PATH = _path_from_webhook_url("/webhook")

async def on_startup(app):
    if WEBHOOK_URL:
        try:
            await bot.set_webhook(WEBHOOK_URL)
            logger.info(f"Webhook —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: {WEBHOOK_URL}")
        except Exception:
            logger.exception("–ù–µ —É–¥–∞–ª–æ—Å—å —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å webhook ‚Äî –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º –±–µ–∑ –Ω–µ–≥–æ")
    else:
        logger.warning("WEBHOOK_URL –Ω–µ –∑–∞–¥–∞–Ω ‚Äî —Å–µ—Ä–≤–µ—Ä –ø–æ–¥–Ω–∏–º–µ—Ç—Å—è, –Ω–æ Telegram –Ω–µ –±—É–¥–µ—Ç –∑–Ω–∞—Ç—å –∫—É–¥–∞ —Å–ª–∞—Ç—å –∞–ø–¥–µ–π—Ç—ã.")

async def on_shutdown(app):
    try:
        await bot.delete_webhook()
    except Exception:
        logger.exception("–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å webhook")
    try:
        session = await bot.get_session()
        await session.close()
    except Exception:
        pass
    logger.info("üëã Shutdown complete")

async def handle_webhook(request):
    try:
        data = await request.json()
        update = types.Update(**data)
        Bot.set_current(bot)
        Dispatcher.set_current(dp)
        await dp.process_update(update)
        return web.Response(status=200)
    except Exception:
        logger.exception("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ webhook")
        return web.Response(status=200)

async def healthcheck(request):
    return web.Response(text="ok")

app = web.Application()
app.router.add_get("/", healthcheck)
app.router.add_post(WEBHOOK_PATH, handle_webhook)
if WEBHOOK_PATH.endswith("/"):
    app.router.add_post(WEBHOOK_PATH.rstrip("/"), handle_webhook)
else:
    app.router.add_post(WEBHOOK_PATH + "/", handle_webhook)
app.on_startup.append(on_startup)
app.on_shutdown.append(on_shutdown)

if __name__ == "__main__":
    web.run_app(app, host=WEBAPP_HOST, port=WEBAPP_PORT)
